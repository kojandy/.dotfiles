#!/usr/bin/env python3
import os
import shutil
import filecmp
import argparse
import subprocess
import configparser
from pathlib import Path

dotfile_path = Path.home() / '.dotfiles'
config_name = 'dfmconfig'

config = configparser.ConfigParser()
config.read(str(dotfile_path / config_name))


def get_path(name):
    return dotfile_path / (name + '@'), Path.home() / ('.' + name)


def linkable():
    for path in dotfile_path.glob('*@'):
        if path.is_file():
            yield path.name[:-1]


def rm(path):
    print('rm %s' % path)
    return path.unlink()


def cp(a, b):
    print('cp %s %s' % (a, b))
    return shutil.copy(str(a), str(b))


def mv(a, b):
    print('mv %s %s' % (a, b))
    return shutil.move(str(a), str(b))


def symlink(a, b):
    print('ln -s %s %s' % (a, b))
    return b.symlink_to(a)


def link(args):
    if args.name:
        if args.merge:
            args.ours = True
            args.theirs = True
        result = __link(args.name, args.ours, args.theirs)
        if result != 0:
            exit(1)

    else:
        unsuccessful = []
        for name in linkable():
            if args.merge:
                args.ours = True
                args.theirs = True
            result = __link(name, args.ours, args.theirs)
            if result != 0:
                unsuccessful.append(name)
        if unsuccessful:
            print('\n\nFollowing files could not be linked:')
            for name in unsuccessful:
                print(name)


def __link(name, ours=False, theirs=False):
    # Return value
    # 0: Success
    # 1: File does not exist
    # 2: Link conflict: Both files
    # 3: Link conflict: Both symlinks

    me, their = get_path(name)

    if me.is_file() != their.is_file():
        if me.is_file():
            symlink(me, their)
        elif their.is_symlink():
            cp(their.resolve(), me)
            rm(their)
            symlink(me, their)
        else:
            mv(their, me)
            symlink(me, their)
    elif me.is_symlink() and their.is_symlink():
        print('Link conflict: Both files are symlinks: %s' % name)
        return 3
    else:
        if me.is_file() and their.is_file():
            if their.resolve() == me:
                print('Already linked: %s' % name)
                return 0
            elif ours and theirs:
                pass
            elif ours or their.is_symlink() or \
                    filecmp.cmp(str(me), str(their)):
                rm(their)
                symlink(me, their)
            elif theirs or me.is_symlink():
                rm(me)
                mv(their, me)
                symlink(me, their)
            else:
                print('Link conflict: Both files have contents: %s' % name)
                return 2
        else:
            print('File does not exist: %s' % me)
            return 1
    return 0


def unlink(args):
    if args.name:
        result = __unlink(args.name)
        if result != 0:
            exit(1)

    else:
        unsuccessful = []
        for name in linkable():
            result = __unlink(name)
            if result != 0:
                unsuccessful.append(name)
        if unsuccessful:
            print('\n\nFollowing files could not be unlinked:')
            for name in unsuccessful:
                print(name)


def __unlink(name):
    # Return value
    # 0: Success
    # 1: Not linked

    me, their = get_path(name)

    if not me.is_file() or not their.is_file() or their.resolve() != me:
        print('Not linked: %s' % name)
        return 1

    rm(their)
    cp(me, their)
    return 0


def remove(args):
    if args.name:
        result = __remove(args.name)
        if result != 0:
            exit(1)

    else:
        unsuccessful = []
        for name in linkable():
            result = __remove(name)
            if result != 0:
                unsuccessful.append(name)
        if unsuccessful:
            print('\n\nFollowing files could not be removed:')
            for name in unsuccessful:
                print(name)


def __remove(name):
    # Return value
    # 0: Success
    # 1: Not linked

    me, their = get_path(name)

    if not me.is_file() or not their.is_file() or their.resolve() != me:
        print('Not linked: %s' % name)
        return 1

    rm(their)
    return 0


def update(args):
    os.chdir(str(dotfile_path))
    subprocess.run(['git', 'pull'])


def install(args):
    try:
        os.system(config['install'][args.name])
    except KeyError:
        print('Install script not found: %s' % args.name)
        exit(1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.required = True

    parser_link = subparsers.add_parser('link', aliases=['ln'])
    parser_link.add_argument('name', type=str, nargs='?')
    group = parser_link.add_mutually_exclusive_group()
    group.add_argument('-m', '--merge', action='store_true')
    group.add_argument('-o', '--ours', action='store_true')
    group.add_argument('-t', '--theirs', action='store_true')
    parser_link.set_defaults(func=link)

    parser_unlink = subparsers.add_parser('unlink', aliases=['uln'])
    parser_unlink.add_argument('name', type=str, nargs='?')
    parser_unlink.set_defaults(func=unlink)

    parser_remove = subparsers.add_parser('remove', aliases=['rm'])
    parser_remove.add_argument('name', type=str, nargs='?')
    parser_remove.set_defaults(func=remove)

    parser_update = subparsers.add_parser('update', aliases=['up'])
    parser_update.set_defaults(func=update)

    parser_install = subparsers.add_parser('install', aliases=['i'])
    parser_install.add_argument('name', type=str)
    parser_install.set_defaults(func=install)

    args = parser.parse_args()
    args.func(args)
