#!/usr/bin/env python3
import os
import json
import shutil
import pprint
import argparse
import subprocess
import configparser
from pathlib import Path

config_name = 'dfmconfig'
status_path = str(Path.home() / '.dfmstatus')
exclude = [config_name, 'setup', 'install', 'setup.sh', 'install.sh']
config_spec = {
    'link': {
        'exclude': ['README.md', 'bin']
    }, 'install': {
        'oh-my-zsh': ""
    }
}
status_spec = {
    'path': '/home/kojandy/.dotfiles',
    'linked': ['vimrc', 'zshrc']
}


def init(args):
    cwd = Path.cwd()
    if cwd == Path.home():
        print('You cannot set home directory as a dotfile dir')
        exit(1)
    status = {'path': str(cwd), 'linked': []}
    print('Dotfile dir: %s' % cwd)
    with open(status_path, 'w') as f:
        json.dump(status, f)


def clone(args):
    pass


def link(args):
    with open(status_path, 'r+') as f:
        status = json.load(f)

        if args.name:
            result = __link(status, args.name, args.merge, args.ours, args.theirs)
            if result != 0:
                exit(1)

            status['linked'].append(args.name)
        else:
            unsuccessful = []
            for path in Path(status['path']).glob('[!.]*'):
                if path.name not in exclude and path.is_file():
                    result = __link(status, path.name, args.merge, args.ours, args.theirs)
                    if result == 0:
                        status['linked'].append(path.name)
                    elif result == 4:
                        pass
                    else:
                        unsuccessful.append(path.name)
            if unsuccessful:
                print('\n\nFollowing files could not be linked:')
                for name in unsuccessful:
                    print(name)
        f.seek(0)
        json.dump(status, f)
        f.truncate()


def __link(status, name, merge=False, ours=False, theirs=False):
    # Return value
    # 0: Success
    # 1: File does not exist
    # 2: Link conflict: Both files
    # 3: Link conflict: Both symlinks
    # 4: Already linked

    if name in status['linked']:
        print('Already linked: %s' % name)
        return 4
    me = Path(status['path']) / name
    their = Path.home() / ('.' + name)

    if me.is_file() != their.is_file():
        if me.is_file():
            their.symlink_to(me)
            print('ln -s %s %s' % (me, their))
        elif their.is_symlink():
            original = their.resolve()
            shutil.copy(str(original), str(me))
            print('cp %s %s' % (original, me))
            their.unlink()
            print('rm %s' % their)
            their.symlink_to(me)
            print('ln -s %s %s' % (me, their))
        else:
            shutil.move(str(their), str(me))
            print('mv %s %s' % (their, me))
            their.symlink_to(me)
            print('ln -s %s %s' % (me, their))
    elif me.is_symlink() and their.is_symlink():
        print('Link conflict: Both files are symlinks: %s' % name)
        return 3
    else:
        if me.is_file() and their.is_file():
            if merge:
                pass
            elif ours or their.is_symlink():
                their.unlink()
                print('rm %s' % their)
                their.symlink_to(me)
                print('ln -s %s %s' % (me, their))
            elif theirs or me.is_symlink():
                me.unlink()
                print('rm %s' % me)
                shutil.move(str(their), str(me))
                print('mv %s %s' % (their, me))
                their.symlink_to(me)
                print('ln -s %s %s' % (me, their))
            else:
                print('Link conflict: Both files have contents: %s' % name)
                return 2
        else:
            print('File does not exist: %s' % me)
            return 1
    return 0


def unlink(args):
    with open(status_path, 'r+') as f:
        status = json.load(f)

        if args.name:
            result = __unlink(status, args.name)
            if result != 0:
                exit(1)

            status['linked'].remove(args.name)
        else:
            unsuccessful = []
            for path in Path(status['path']).glob('[!.]*'):
                if path.name not in exclude and path.is_file():
                    result = __unlink(status, path.name)
                    if result == 0:
                        status['linked'].remove(path.name)
                    else:
                        unsuccessful.append(path.name)
            if unsuccessful:
                print('\n\nFollowing files could not be unlinked:')
                for name in unsuccessful:
                    print(name)

        f.seek(0)
        json.dump(status, f)
        f.truncate()


def __unlink(status, name):
    # Return value
    # 0: Success
    # 1: Not linked

    if name not in status['linked']:
        print('Not linked: %s' % name)
        return 1
    me = Path(status['path']) / name
    their = Path.home() / ('.' + name)
    their.unlink()
    print('rm %s' % their)
    shutil.copy(str(me), str(their))
    print('cp %s %s' % (me, their))
    return 0


def copy(args):
    pass


def remove(args):
    with open(status_path, 'r+') as f:
        status = json.load(f)

        if args.name:
            pass
        else:
            pass


def ignore(args):
    pass


def update(args):
    with open(status_path) as f:
        status = json.load(f)
        os.chdir(status['path'])
        result = subprocess.run(['git', 'pull'])


def refresh(args):
    with open(status_path, 'r+') as f:
        status = json.load(f)

        linked = []
        for path in Path(status['path']).glob('[!.]*'):
            if path.name not in exclude and path.is_file():
                me = path
                their = Path.home() / ('.' + path.name)
                if their.is_symlink() and their.resolve() == me:
                    linked.append(path.name)

        status['linked'] = linked
        print(linked)
        f.seek(0)
        json.dump(status, f)
        f.truncate()


def status(args):
    with open(status_path) as f:
        pprint.pprint(json.load(f))

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.required = True

    parser_init = subparsers.add_parser('init')
    parser_init.set_defaults(func=init)

    parser_clone = subparsers.add_parser('clone')
    parser_clone.add_argument('git', type=str)
    parser_clone.add_argument('name', type=str, nargs='?')
    parser_clone.set_defaults(func=clone)

    parser_link = subparsers.add_parser('link')
    parser_link.add_argument('name', type=str, nargs='?')
    group = parser_link.add_mutually_exclusive_group()
    group.add_argument('-m', '--merge', action='store_true')
    group.add_argument('-o', '--ours', action='store_true')
    group.add_argument('-t', '--theirs', action='store_true')
    parser_link.set_defaults(func=link)

    parser_unlink = subparsers.add_parser('unlink')
    parser_unlink.add_argument('name', type=str, nargs='?')
    parser_unlink.set_defaults(func=unlink)

    parser_copy = subparsers.add_parser('copy')
    parser_copy.add_argument('name', type=str, nargs='?')
    parser_copy.set_defaults(func=copy)

    parser_remove = subparsers.add_parser('remove')
    parser_remove.add_argument('name', type=str, nargs='?')
    parser_remove.set_defaults(func=remove)

    parser_ignore = subparsers.add_parser('ignore')
    parser_ignore.set_defaults(func=ignore)

    parser_update = subparsers.add_parser('update')
    parser_update.set_defaults(func=update)

    parser_refresh = subparsers.add_parser('refresh')
    parser_refresh.set_defaults(func=refresh)

    parser_status = subparsers.add_parser('status')
    parser_status.set_defaults(func=status)

    args = parser.parse_args()
    try:
        args.func(args)
    except FileNotFoundError:
        print('Dotfile dir not set')
        exit(1)
    except json.decoder.JSONDecodeError:
        print('~/.dfmstatus broken')
        exit(1)
